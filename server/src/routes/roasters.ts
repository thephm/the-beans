import { Router } from 'express';
import { body, validationResult, param, query } from 'express-validator';
import { PrismaClient } from '@prisma/client';
import { upload, deleteImage, uploadImageFromUrl } from '../lib/cloudinary';
import { canEditRoaster } from '../middleware/roasterAuth';
import { auditBefore, auditAfter, captureOldValues, storeEntityForAudit } from '../middleware/auditMiddleware';
import { createAuditLog, getClientIP, getUserAgent, getEntityName } from '../lib/auditService';

const router = Router();
const prisma = new PrismaClient();

// Middleware to extract user from token (optional for public routes)
const optionalAuth = async (req: any, res: any, next: any) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    if (token) {
      const jwt = require('jsonwebtoken');
      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret') as { userId: string };
      req.userId = decoded.userId;
    }
    next();
  } catch (error) {
    next(); // Continue without user authentication
  }
};

// Required auth middleware
const requireAuth = async (req: any, res: any, next: any) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const jwt = require('jsonwebtoken');
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret') as { userId: string };
    req.userId = decoded.userId;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

/**
 * @swagger
 * components:
 *   schemas:
 *     Roaster:
 *       type: object
 *       required:
 *         - name
 *       properties:
 *         id:
 *           type: string
 *         name:
 *           type: string
 *         description:
 *           type: string
 *         email:
 *           type: string
 *         phone:
 *           type: string
 *         website:
 *           type: string
 *         address:
 *           type: string
 *         city:
 *           type: string
 *         state:
 *           type: string
 *         zipCode:
 *           type: string
 *         country:
 *           type: string
 *         latitude:
 *           type: number
 *         longitude:
 *           type: number
 *         images:
 *           type: array
 *           items:
 *             type: string
 *         hours:
 *           type: object
 *         specialties:
 *           type: array
 *           items:
 *             type: string
 *         verified:
 *           type: boolean
 *         featured:
 *           type: boolean
 *         rating:
 *           type: number
 *         reviewCount:
 *           type: integer
 */

/**
 * @swagger
 * /api/roasters:
 *   get:
 *     summary: Get all roasters with filtering and pagination
 *     tags: [Roasters]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 20
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 *       - in: query
 *         name: city
 *         schema:
 *           type: string
 *       - in: query
 *         name: state
 *         schema:
 *           type: string
 *       - in: query
 *         name: specialty
 *         schema:
 *           type: string
 *       - in: query
 *         name: latitude
 *         schema:
 *           type: number
 *       - in: query
 *         name: longitude
 *         schema:
 *           type: number
 *       - in: query
 *         name: radius
 *         schema:
 *           type: number
 *           default: 50
 *     responses:
 *       200:
 *         description: List of roasters
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 roasters:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Roaster'
 *                 pagination:
 *                   type: object
 *                   properties:
 *                     page:
 *                       type: integer
 *                     limit:
 *                       type: integer
 *                     total:
 *                       type: integer
 *                     pages:
 *                       type: integer
 */
router.get('/', [
  query('page').optional().isInt({ min: 1 }),
  query('limit').optional().isInt({ min: 1, max: 100 }),
  query('latitude').optional().isFloat(),
  query('longitude').optional().isFloat(),
  query('radius').optional().isFloat({ min: 1, max: 500 }),
  query('sort').optional().isString(),
], optionalAuth, async (req: any, res: any) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;
    
    const { search, city, state, specialty, latitude, longitude, radius = 50, sort } = req.query;

    // Build orderBy clause based on sort parameter
    let orderBy: any[] = [];
    
    switch (sort) {
      case 'name':
        orderBy = [{ name: 'asc' }];
        break;
      case '-name':
        orderBy = [{ name: 'desc' }];
        break;
      case '-rating':
        orderBy = [{ rating: 'desc' }];
        break;
      case '-reviewCount':
        orderBy = [{ reviewCount: 'desc' }];
        break;
      case 'city':
        orderBy = [{ city: 'asc' }];
        break;
      default:
        // Default sorting when no sort parameter or invalid value
        orderBy = [
          { featured: 'desc' },
          { rating: 'desc' },
          { reviewCount: 'desc' },
        ];
    }

    // Build where clause
    const where: any = {};
    
    // Get current user's role to determine if they can see unverified roasters
    let userRole = 'user'; // Default to regular user
    if (req.userId) {
      const currentUser = await prisma.user.findUnique({
        where: { id: req.userId },
        select: { role: true, settings: true }
      });
      if (currentUser) {
        userRole = currentUser.role;
      }
    }
    
    // Only show verified roasters to non-admin users
    if (userRole !== 'admin') {
      where.verified = true;
    }
    
    if (search) {
      where.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } },
        { specialties: { has: search } },
      ];
    }
    
    if (city) {
      where.city = { contains: city, mode: 'insensitive' };
    }
    
    if (state) {
      where.state = { contains: state, mode: 'insensitive' };
    }
    
    if (specialty) {
      where.specialties = { has: specialty };
    }

    // Get roasters
    const roasters = await prisma.roaster.findMany({
      where,
      skip,
      take: limit,
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
          }
        },
        people: {
          where: { isActive: true },
          include: {
            user: {
              select: {
                id: true,
                username: true,
                firstName: true,
                lastName: true,
                email: true,
              }
            }
          },
          orderBy: [
            { isPrimary: 'desc' },
            { createdAt: 'asc' }
          ]
        },
        roasterImages: {
          orderBy: [
            { isPrimary: 'desc' },
            { uploadedAt: 'asc' }
          ]
        },
        _count: {
          select: {
            reviews: true,
            favorites: true,
          }
        }
      },
      orderBy: orderBy
    });

    // If location-based search, filter by distance
    let filteredRoasters = roasters;
    if (latitude && longitude) {
      filteredRoasters = roasters.filter(roaster => {
        if (!roaster.latitude || !roaster.longitude) return false;
        
        const distance = calculateDistance(
          parseFloat(latitude),
          parseFloat(longitude),
          roaster.latitude,
          roaster.longitude
        );
        
        return distance <= parseFloat(radius);
      });
    }

    const total = await prisma.roaster.count({ where });
    const pages = Math.ceil(total / limit);

    // Add imageUrl field for frontend compatibility
    const roastersWithImageUrl = filteredRoasters.map((roaster: any) => {
      // Use the primary image from roasterImages if available, fall back to old images array
      let imageUrl = null;
      if (roaster.roasterImages && roaster.roasterImages.length > 0) {
        // Find primary image first, or use the first image (they're ordered by isPrimary desc)
        imageUrl = roaster.roasterImages[0].url;
      } else if (roaster.images && roaster.images.length > 0) {
        // Fall back to old images array
        imageUrl = roaster.images[0];
      }

      const result = {
        ...roaster,
        imageUrl,
      };
      
      // Round rating to 1 decimal place
      if (roaster.rating && typeof roaster.rating === 'number') {
        result.rating = parseFloat(roaster.rating.toFixed(1));
      }
      
      // Round distance to 1 decimal place (only available if location filtering was applied)
      if (roaster.distance && typeof roaster.distance === 'number') {
        result.distance = parseFloat(roaster.distance.toFixed(1));
      }
      
      return result;
    });

    res.json({
      roasters: roastersWithImageUrl,
      pagination: {
        page,
        limit,
        total,
        pages,
      }
    });
  } catch (error) {
    console.error('Get roasters error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/roasters/{id}:
 *   get:
 *     summary: Get roaster by ID
 *     tags: [Roasters]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Roaster details
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Roaster'
 *       404:
 *         description: Roaster not found
 */
router.get('/:id', [
  param('id').isString(),
], optionalAuth, async (req: any, res: any) => {
  try {
    const { id } = req.params;
    
    const roaster = await prisma.roaster.findUnique({
      where: { id },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
          }
        },
        beans: true,
        roasterImages: {
          orderBy: [
            { isPrimary: 'desc' },
            { uploadedAt: 'asc' }
          ]
        },
        reviews: {
          include: {
            user: {
              select: {
                id: true,
                username: true,
                firstName: true,
                lastName: true,
                avatar: true,
              }
            }
          },
          orderBy: { createdAt: 'desc' },
          take: 10,
        },
        _count: {
          select: {
            reviews: true,
            favorites: true,
          }
        }
      }
    });

    if (!roaster) {
      return res.status(404).json({ error: 'Roaster not found' });
    }

    // Check if current user is admin or if roaster is verified
    let userRole = 'user';
    if (req.userId) {
      const currentUser = await prisma.user.findUnique({
        where: { id: req.userId },
        select: { role: true }
      });
      if (currentUser) {
        userRole = currentUser.role;
      }
    }
    
    // Non-admin users can only see verified roasters
    if (userRole !== 'admin' && !roaster.verified) {
      return res.status(404).json({ error: 'Roaster not found' });
    }

    // Check if current user has favorited this roaster
    let isFavorited = false;
    if (req.userId) {
      const favorite = await prisma.favorite.findUnique({
        where: {
          userId_roasterId: {
            userId: req.userId,
            roasterId: id,
          }
        }
      });
      isFavorited = !!favorite;
    }

    // Add imageUrl field for frontend compatibility (filename only)
    // Use the primary image from roasterImages if available, fall back to old images array
    let imageUrl = null;
    if (roaster.roasterImages && roaster.roasterImages.length > 0) {
      // Find primary image first, or use the first image (they're ordered by isPrimary desc)
      imageUrl = roaster.roasterImages[0].url;
    } else if (roaster.images && roaster.images.length > 0) {
      // Fall back to old images array
      imageUrl = roaster.images[0];
    }

    const roasterWithImageUrl = {
      ...roaster,
      imageUrl,
      isFavorited,
    };

    res.json(roasterWithImageUrl);
  } catch (error) {
    console.error('Get roaster error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/roasters:
 *   post:
 *     summary: Create a new roaster
 *     tags: [Roasters]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *             properties:
 *               name:
 *                 type: string
 *               description:
 *                 type: string
 *               email:
 *                 type: string
 *               phone:
 *                 type: string
 *               website:
 *                 type: string
 *               address:
 *                 type: string
 *               city:
 *                 type: string
 *               state:
 *                 type: string
 *               zipCode:
 *                 type: string
 *               latitude:
 *                 type: number
 *               longitude:
 *                 type: number
 *               specialties:
 *                 type: array
 *                 items:
 *                   type: string
 *     responses:
 *       201:
 *         description: Roaster created successfully
 *       401:
 *         description: Unauthorized
 */
router.post('/', [
  body('name').isLength({ min: 1, max: 100 }).withMessage('Name is required and must be between 1-100 characters'),
  body('description').optional().isLength({ max: 1000 }).withMessage('Description must be less than 1000 characters'),
  body('email').optional({ checkFalsy: true }).isEmail().withMessage('Please enter a valid email address'),
  body('phone').optional().isLength({ max: 20 }).withMessage('Phone number must be less than 20 characters'),
  body('website').optional({ checkFalsy: true }).isURL().withMessage('Please enter a valid website URL'),
  body('address').optional().isLength({ max: 200 }).withMessage('Address must be less than 200 characters'),
  body('city').optional().isLength({ max: 100 }).withMessage('City must be less than 100 characters'),
  body('state').optional().isLength({ max: 50 }).withMessage('State must be less than 50 characters'),
  body('zipCode').optional().isLength({ max: 20 }).withMessage('Zip code must be less than 20 characters'),
  body('latitude').optional().isFloat({ min: -90, max: 90 }).withMessage('Latitude must be between -90 and 90'),
  body('longitude').optional().isFloat({ min: -180, max: 180 }).withMessage('Longitude must be between -180 and 180'),
  body('specialties').optional().isArray().withMessage('Specialties must be an array'),
  // New nested owner contact validation
  body('ownerContact.email').optional({ checkFalsy: true }).isEmail().withMessage('Please enter a valid owner email address'),
  body('ownerContact.name').optional().isLength({ max: 100 }).withMessage('Owner name must be less than 100 characters'),
  body('ownerContact.bio').optional().isLength({ max: 1000 }).withMessage('Owner bio must be less than 1000 characters'),
  body('ownerContact.mobile').optional().isLength({ max: 20 }).withMessage('Owner mobile must be less than 20 characters'),
  
  // Legacy individual field validation (for backward compatibility)
  body('ownerEmail').optional({ checkFalsy: true }).isEmail().withMessage('Please enter a valid owner email address'),
  // Removed legacy ownerName, ownerBio, ownerMobile validation
], requireAuth, auditBefore('roaster', 'CREATE'), async (req: any, res: any) => {
  try {
    console.log('Roaster creation - audit setup:', { userId: req.userId, hasAuditData: !!req.auditData });
    
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    let ownerId = req.userId; // Default to current user
    
    // If ownerEmail is provided, find the owner by email
    if (req.body.ownerEmail && req.body.ownerEmail.trim() !== '') {
      const ownerUser = await prisma.user.findUnique({
        where: { email: req.body.ownerEmail },
        select: { id: true }
      });
      
      if (!ownerUser) {
        return res.status(400).json({ error: 'Owner email not found. User must be registered first.' });
      }
      
      ownerId = ownerUser.id;
    }

    const roasterData = {
      ...req.body,
      ownerId: ownerId,
    };
    
    // Remove ownerEmail from data as it's not part of the schema
    delete roasterData.ownerEmail;

    const roaster = await prisma.roaster.create({
      data: {
        ...roasterData,
        createdById: req.userId, // Track who created it
      },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            email: true,
          }
        }
      }
    });

    // Process any image URLs in the images array - upload them to Cloudinary
    if (roasterData.images && Array.isArray(roasterData.images) && roasterData.images.length > 0) {
      try {
        const imageUploadPromises = roasterData.images.map(async (imageUrl: string, index: number) => {
          // Check if it's an external URL (not already a Cloudinary URL)
          if (imageUrl && typeof imageUrl === 'string' && imageUrl.startsWith('http') && !imageUrl.includes('cloudinary.com')) {
            const uploadResult = await uploadImageFromUrl(imageUrl, roaster.id);
            if (uploadResult) {
              // Create a RoasterImage record
              await prisma.roasterImage.create({
                data: {
                  roasterId: roaster.id,
                  url: uploadResult.url,
                  publicId: uploadResult.publicId,
                  isPrimary: index === 0, // First image is primary
                  uploadedById: req.userId,
                }
              });
              return uploadResult.url;
            }
          }
          return imageUrl; // Return original URL if already processed or failed
        });

        const processedImages = await Promise.all(imageUploadPromises);
        
        // Update the roaster's images array with the new Cloudinary URLs
        await prisma.roaster.update({
          where: { id: roaster.id },
          data: { 
            images: processedImages.filter(Boolean) // Remove any null/undefined results
          }
        });
      } catch (imageError) {
        console.error('Error processing images for roaster:', imageError);
        // Don't fail the roaster creation if image processing fails
      }
    }

    // Store entity for audit logging
    res.locals.auditEntity = roaster;
    console.log('Roaster creation - stored entity for audit:', { roasterId: roaster.id, hasAuditEntity: !!res.locals.auditEntity });

    // Create audit log manually to ensure it works
    if (req.auditData && req.userId) {
      const auditLogData = {
        action: req.auditData.action,
        entityType: req.auditData.entityType,
        entityId: roaster.id,
        entityName: getEntityName(req.auditData.entityType, roaster),
        userId: req.userId,
        ipAddress: getClientIP(req),
        userAgent: getUserAgent(req),
        oldValues: req.auditData.oldValues,
        newValues: roaster
      };
      
      console.log('Creating roaster audit log manually:', { action: auditLogData.action, entityId: auditLogData.entityId, userId: auditLogData.userId });
      
      // Create audit log asynchronously (don't block the response)
      setTimeout(() => createAuditLog(auditLogData), 0);
    } else {
      console.log('Roaster audit log NOT created - missing requirements:', { hasAuditData: !!req.auditData, hasUserId: !!req.userId });
    }

    res.status(201).json({
      message: 'Roaster created successfully',
      roaster,
    });
  } catch (error) {
    console.error('Create roaster error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}, auditAfter());

/**
 * @swagger
 * /api/roasters/{id}:
 *   put:
 *     summary: Update a roaster (admin only)
 *     tags: [Roasters]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               description:
 *                 type: string
 *               email:
 *                 type: string
 *               phone:
 *                 type: string
 *               website:
 *                 type: string
 *               address:
 *                 type: string
 *               city:
 *                 type: string
 *               state:
 *                 type: string
 *               zipCode:
 *                 type: string
 *               country:
 *                 type: string
 *               latitude:
 *                 type: number
 *               longitude:
 *                 type: number
 *               specialties:
 *                 type: array
 *                 items:
 *                   type: string
 *               verified:
 *                 type: boolean
 *               featured:
 *                 type: boolean
 *               rating:
 *                 type: number
 *     responses:
 *       200:
 *         description: Roaster updated successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Admin access required
 *       404:
 *         description: Roaster not found
 */
router.put('/:id', [
  param('id').isString(),
  body('name').optional().isLength({ min: 1, max: 100 }).withMessage('Name must be between 1-100 characters'),
  body('description').optional().isLength({ max: 1000 }).withMessage('Description must be less than 1000 characters'),
  body('email').optional({ checkFalsy: true }).isEmail().withMessage('Please enter a valid email address'),
  body('phone').optional().isLength({ max: 20 }).withMessage('Phone number must be less than 20 characters'),
  body('website').optional({ checkFalsy: true }).isURL().withMessage('Please enter a valid website URL'),
  body('address').optional().isLength({ max: 200 }).withMessage('Address must be less than 200 characters'),
  body('city').optional().isLength({ max: 100 }).withMessage('City must be less than 100 characters'),
  body('state').optional().isLength({ max: 50 }).withMessage('State must be less than 50 characters'),
  body('zipCode').optional().isLength({ max: 20 }).withMessage('Zip code must be less than 20 characters'),
  body('country').optional().isLength({ max: 100 }).withMessage('Country must be less than 100 characters'),
  body('latitude').optional().isFloat({ min: -90, max: 90 }).withMessage('Latitude must be between -90 and 90'),
  body('longitude').optional().isFloat({ min: -180, max: 180 }).withMessage('Longitude must be between -180 and 180'),
  body('specialties').optional().isArray().withMessage('Specialties must be an array'),
  body('verified').optional().isBoolean().withMessage('Verified must be true or false'),
  body('featured').optional().isBoolean().withMessage('Featured must be true or false'),
  body('rating').optional().isFloat({ min: 0, max: 5 }).withMessage('Rating must be between 0 and 5'),
  body('ownerEmail').optional({ checkFalsy: true }).isEmail().withMessage('Please enter a valid owner email address'),
  // Removed legacy ownerName, ownerBio, ownerMobile validation
], requireAuth, auditBefore('roaster', 'UPDATE'), captureOldValues(prisma.roaster), async (req: any, res: any) => {
  try {
    console.log('Roaster UPDATE - audit setup:', { userId: req.userId, hasAuditData: !!req.auditData, hasOldValues: !!req.auditData?.oldValues });
    
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    // Check if user is admin
    const user = await prisma.user.findUnique({
      where: { id: req.userId },
      select: { role: true }
    });

    if (!user || user.role !== 'admin') {
      return res.status(403).json({ error: 'Admin access required' });
    }

    const { id } = req.params;
  const updateData = { ...req.body };
  // Remove deprecated contact fields if present
  delete updateData.ownerName;
  delete updateData.ownerBio;
  delete updateData.ownerMobile;

    // Handle ownerEmail if provided
    if (updateData.ownerEmail !== undefined) {
      if (updateData.ownerEmail && updateData.ownerEmail.trim() !== '') {
        const ownerUser = await prisma.user.findUnique({
          where: { email: updateData.ownerEmail },
          select: { id: true }
        });
        
        if (!ownerUser) {
          return res.status(400).json({ error: 'Owner email not found. User must be registered first.' });
        }
        
        updateData.ownerId = ownerUser.id;
      } else {
        // If ownerEmail is empty, set ownerId to null (no owner)
        updateData.ownerId = null;
      }
      
      // Remove ownerEmail from data as it's not part of the schema
      delete updateData.ownerEmail;
    }

    // Remove undefined values
    Object.keys(updateData).forEach(key => {
      if (updateData[key] === undefined) {
        delete updateData[key];
      }
    });

    const roaster = await prisma.roaster.update({
      where: { id },
      data: {
        ...updateData,
        updatedById: req.userId, // Track who updated it
      },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            email: true,
          }
        }
      }
    });

    // Process any image URLs in the images array - upload them to Cloudinary
    if (updateData.images && Array.isArray(updateData.images) && updateData.images.length > 0) {
      try {
        const imageUploadPromises = updateData.images.map(async (imageUrl: string, index: number) => {
          // Check if it's an external URL (not already a Cloudinary URL)
          if (imageUrl && typeof imageUrl === 'string' && imageUrl.startsWith('http') && !imageUrl.includes('cloudinary.com')) {
            const uploadResult = await uploadImageFromUrl(imageUrl, roaster.id);
            if (uploadResult) {
              // Check if this roaster already has images, to determine if this should be primary
              const existingImageCount = await prisma.roasterImage.count({
                where: { roasterId: roaster.id }
              });
              
              // Create a RoasterImage record
              await prisma.roasterImage.create({
                data: {
                  roasterId: roaster.id,
                  url: uploadResult.url,
                  publicId: uploadResult.publicId,
                  isPrimary: existingImageCount === 0 && index === 0, // First image is primary only if no existing images
                  uploadedById: req.userId,
                }
              });
              return uploadResult.url;
            }
          }
          return imageUrl; // Return original URL if already processed or failed
        });

        const processedImages = await Promise.all(imageUploadPromises);
        
        // Update the roaster's images array with the new Cloudinary URLs
        await prisma.roaster.update({
          where: { id: roaster.id },
          data: { 
            images: processedImages.filter(Boolean) // Remove any null/undefined results
          }
        });
      } catch (imageError) {
        console.error('Error processing images for roaster update:', imageError);
        // Don't fail the roaster update if image processing fails
      }
    }

    // Store entity for audit logging
    res.locals.auditEntity = roaster;

    // Create audit log manually to ensure it works
    if (req.auditData && req.userId) {
      const auditLogData = {
        action: req.auditData.action,
        entityType: req.auditData.entityType,
        entityId: roaster.id,
        entityName: getEntityName(req.auditData.entityType, roaster),
        userId: req.userId,
        ipAddress: getClientIP(req),
        userAgent: getUserAgent(req),
        oldValues: req.auditData.oldValues,
        newValues: roaster
      };
      
      console.log('Creating roaster UPDATE audit log manually:', { action: auditLogData.action, entityId: auditLogData.entityId, userId: auditLogData.userId });
      
      // Create audit log asynchronously (don't block the response)
      setTimeout(() => createAuditLog(auditLogData), 0);
    } else {
      console.log('Roaster UPDATE audit log NOT created - missing requirements:', { hasAuditData: !!req.auditData, hasUserId: !!req.userId });
    }

    res.json({
      message: 'Roaster updated successfully',
      roaster,
    });
  } catch (error: any) {
    console.error('Update roaster error:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Roaster not found' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
}, auditAfter());

/**
 * @swagger
 * /api/roasters/{id}:
 *   delete:
 *     summary: Delete a roaster (admin only)
 *     tags: [Roasters]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Roaster deleted successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Admin access required
 *       404:
 *         description: Roaster not found
 */
router.delete('/:id', [
  param('id').isString(),
], requireAuth, auditBefore('roaster', 'DELETE'), captureOldValues(prisma.roaster), async (req: any, res: any) => {
  try {
    console.log('Roaster DELETE - audit setup:', { userId: req.userId, hasAuditData: !!req.auditData, hasOldValues: !!req.auditData?.oldValues });
    
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    // Check if user is admin
    const user = await prisma.user.findUnique({
      where: { id: req.userId },
      select: { role: true }
    });

    if (!user || user.role !== 'admin') {
      return res.status(403).json({ error: 'Admin access required' });
    }

    const { id } = req.params;

    // Store the deleted entity for audit (it's already captured in oldValues)
    const deletedEntity = req.auditData?.oldValues || { id };
    res.locals.auditEntity = deletedEntity;

    await prisma.roaster.delete({
      where: { id }
    });

    // Create audit log manually to ensure it works (for DELETE operations)
    if (req.auditData && req.userId) {
      const auditLogData = {
        action: req.auditData.action,
        entityType: req.auditData.entityType,
        entityId: id,
        entityName: getEntityName(req.auditData.entityType, deletedEntity),
        userId: req.userId,
        ipAddress: getClientIP(req),
        userAgent: getUserAgent(req),
        oldValues: req.auditData.oldValues,
        newValues: undefined // For deletes, newValues should be undefined
      };
      
      console.log('Creating roaster DELETE audit log manually:', { action: auditLogData.action, entityId: auditLogData.entityId, userId: auditLogData.userId });
      
      // Create audit log asynchronously (don't block the response)
      setTimeout(() => createAuditLog(auditLogData), 0);
    } else {
      console.log('Roaster DELETE audit log NOT created - missing requirements:', { hasAuditData: !!req.auditData, hasUserId: !!req.userId });
    }

    res.json({
      message: 'Roaster deleted successfully',
    });
  } catch (error: any) {
    console.error('Delete roaster error:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Roaster not found' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
}, auditAfter());

/**
 * @swagger
 * /api/roasters/admin/unverified:
 *   get:
 *     summary: Get all unverified roasters (admin only)
 *     tags: [Roasters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 20
 *     responses:
 *       200:
 *         description: List of unverified roasters
 *       403:
 *         description: Admin access required
 */
router.get('/admin/unverified', [
  query('page').optional().isInt({ min: 1 }),
  query('limit').optional().isInt({ min: 1, max: 100 }),
], requireAuth, async (req: any, res: any) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    // Check if user is admin
    const user = await prisma.user.findUnique({
      where: { id: req.userId },
      select: { role: true }
    });

    if (!user || user.role !== 'admin') {
      return res.status(403).json({ error: 'Admin access required' });
    }

    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;

    // Get unverified roasters
    const roasters = await prisma.roaster.findMany({
      where: { verified: false },
      skip,
      take: limit,
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
          }
        },
        roasterImages: {
          orderBy: [
            { isPrimary: 'desc' },
            { uploadedAt: 'asc' }
          ]
        },
        _count: {
          select: {
            reviews: true,
            favorites: true,
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    const total = await prisma.roaster.count({ where: { verified: false } });
    const pages = Math.ceil(total / limit);

    // Add imageUrl field for frontend compatibility (filename only)
    const roastersWithImageUrl = roasters.map((roaster: any) => {
      // Use the primary image from roasterImages if available, fall back to old images array
      let imageUrl = null;
      if (roaster.roasterImages && roaster.roasterImages.length > 0) {
        // Find primary image first, or use the first image (they're ordered by isPrimary desc)
        imageUrl = roaster.roasterImages[0].url;
      } else if (roaster.images && roaster.images.length > 0) {
        // Fall back to old images array
        imageUrl = roaster.images[0];
      }

      return {
        ...roaster,
        imageUrl,
      };
    });

    res.json({
      roasters: roastersWithImageUrl,
      pagination: {
        page,
        limit,
        total,
        pages,
      }
    });
  } catch (error) {
    console.error('Get unverified roasters error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/roasters/{id}/verify:
 *   patch:
 *     summary: Verify a roaster (admin only)
 *     tags: [Roasters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Roaster verified successfully
 *       403:
 *         description: Admin access required
 *       404:
 *         description: Roaster not found
 */
router.patch('/:id/verify', [
  param('id').isString(),
], requireAuth, auditBefore('roaster', 'UPDATE'), captureOldValues(prisma.roaster), async (req: any, res: any) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    // Check if user is admin
    const user = await prisma.user.findUnique({
      where: { id: req.userId },
      select: { role: true }
    });

    if (!user || user.role !== 'admin') {
      return res.status(403).json({ error: 'Admin access required' });
    }

    const { id } = req.params;

    const roaster = await prisma.roaster.update({
      where: { id },
      data: { verified: true },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
          }
        }
      }
    });

    // Store entity for audit logging
    res.locals.auditEntity = roaster;

    res.json({
      message: 'Roaster verified successfully',
      roaster,
    });
  } catch (error: any) {
    console.error('Verify roaster error:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Roaster not found' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
}, auditAfter());

// Helper function to calculate distance between two points
function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 3959; // Earth's radius in miles
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

/**
 * @swagger
 * /api/roasters/{id}/images:
 *   get:
 *     summary: Get all images for a roaster
 *     tags: [Roasters]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: List of roaster images
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 images:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: string
 *                       url:
 *                         type: string
 *                       description:
 *                         type: string
 *                       isPrimary:
 *                         type: boolean
 *                       uploadedAt:
 *                         type: string
 *       404:
 *         description: Roaster not found
 */
router.get('/:id/images', [
  param('id').isString(),
], async (req: any, res: any) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { id } = req.params;

    const roaster = await prisma.roaster.findUnique({
      where: { id },
      include: {
        roasterImages: {
          orderBy: [
            { isPrimary: 'desc' },
            { uploadedAt: 'asc' }
          ],
          select: {
            id: true,
            url: true,
            description: true,
            isPrimary: true,
            uploadedAt: true,
            filename: true
          }
        }
      }
    });

    if (!roaster) {
      return res.status(404).json({ error: 'Roaster not found' });
    }

    res.json({
      images: roaster.roasterImages,
    });
  } catch (error) {
    console.error('Get roaster images error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/roasters/{id}/images:
 *   post:
 *     summary: Upload images to a roaster (owner or admin only)
 *     tags: [Roasters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               images:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: binary
 *               descriptions:
 *                 type: array
 *                 items:
 *                   type: string
 *                 description: Optional descriptions for each image
 *               setPrimary:
 *                 type: integer
 *                 description: Index of image to set as primary (0-based)
 *     responses:
 *       201:
 *         description: Images uploaded successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Only owner or admin can upload images
 *       404:
 *         description: Roaster not found
 */
router.post('/:id/images', [
  param('id').isString(),
], requireAuth, auditBefore('roaster_image', 'CREATE'), canEditRoaster, upload.array('images', 10), async (req: any, res: any) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.locals.errorMessage = `Validation failed: ${errors.array().map(e => e.msg).join(', ')}`;
      return res.status(400).json({ errors: errors.array() });
    }

    const { id: roasterId } = req.params;
    const { descriptions = [], setPrimary } = req.body;
    const files = req.files as Express.Multer.File[];

    if (!files || files.length === 0) {
      return res.status(400).json({ error: 'No images provided' });
    }

    // Parse descriptions if it's a string (from form data)
    let imageDescriptions: string[] = [];
    if (typeof descriptions === 'string') {
      try {
        imageDescriptions = JSON.parse(descriptions);
      } catch {
        imageDescriptions = [descriptions];
      }
    } else if (Array.isArray(descriptions)) {
      imageDescriptions = descriptions;
    }

    // Create image records in database
    const imagePromises = files.map(async (file: any, index: number) => {
      const isPrimary = setPrimary ? parseInt(setPrimary) === index : false;
      
      // For Cloudinary, file.path is the full URL and file.filename is the public_id
      const imageUrl = file.path; // Cloudinary URL
      const publicId = file.filename; // Cloudinary public_id
      
      return prisma.roasterImage.create({
        data: {
          url: imageUrl,
          publicId: publicId,
          filename: file.originalname,
          description: imageDescriptions[index] || null,
          isPrimary,
          roasterId,
          uploadedById: req.userId,
        },
      });
    });

    const createdImages = await Promise.all(imagePromises);

    // If setting a new primary image, unset previous primary
    if (setPrimary !== undefined) {
      const primaryIndex = parseInt(setPrimary);
      if (primaryIndex >= 0 && primaryIndex < createdImages.length) {
        await prisma.roasterImage.updateMany({
          where: {
            roasterId,
            id: { not: createdImages[primaryIndex].id }
          },
          data: { isPrimary: false }
        });
      }
    }

    // Update the roaster's images array for backward compatibility
    const allImages = await prisma.roasterImage.findMany({
      where: { roasterId },
      orderBy: [{ isPrimary: 'desc' }, { uploadedAt: 'asc' }],
      select: { url: true }
    });

    await prisma.roaster.update({
      where: { id: roasterId },
      data: {
        images: allImages.map(img => img.url)
      }
    });

    // Store entity for audit logging
    res.locals.auditEntity = createdImages.length > 0 ? createdImages[0] : null;
    res.status(201).json({
      message: 'Images uploaded successfully',
      images: createdImages.map(img => ({
        id: img.id,
        url: img.url,
        description: img.description,
        isPrimary: img.isPrimary,
        uploadedAt: img.uploadedAt,
        filename: img.filename
      })),
    });
  } catch (error) {
    console.error('Upload roaster images error:', error);
    res.locals.errorMessage = error instanceof Error ? error.message : 'Internal server error';
    res.status(500).json({ error: 'Internal server error' });
  }
}, auditAfter());

/**
 * @swagger
 * /api/roasters/{id}/images/{imageId}:
 *   put:
 *     summary: Update image details (owner or admin only)
 *     tags: [Roasters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *       - in: path
 *         name: imageId
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               description:
 *                 type: string
 *               isPrimary:
 *                 type: boolean
 *     responses:
 *       200:
 *         description: Image updated successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Only owner or admin can update images
 *       404:
 *         description: Roaster or image not found
 */
router.put('/:id/images/:imageId', [
  param('id').isString(),
  param('imageId').isString(),
  body('description').optional().isString(),
  body('isPrimary').optional().isBoolean(),
], requireAuth, auditBefore('roaster_image', 'UPDATE'), captureOldValues(prisma.roasterImage, 'imageId'), canEditRoaster, async (req: any, res: any) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { id: roasterId, imageId } = req.params;
    const { description, isPrimary } = req.body;

    // Check if image belongs to this roaster
    const existingImage = await prisma.roasterImage.findFirst({
      where: {
        id: imageId,
        roasterId
      }
    });

    if (!existingImage) {
      return res.status(404).json({ error: 'Image not found' });
    }

    // If setting as primary, unset other primary images
    if (isPrimary) {
      await prisma.roasterImage.updateMany({
        where: {
          roasterId,
          id: { not: imageId }
        },
        data: { isPrimary: false }
      });
    }

    const updatedImage = await prisma.roasterImage.update({
      where: { id: imageId },
      data: {
        description: description !== undefined ? description : undefined,
        isPrimary: isPrimary !== undefined ? isPrimary : undefined,
      },
    });

    // Update the roaster's images array for backward compatibility
    const allImages = await prisma.roasterImage.findMany({
      where: { roasterId },
      orderBy: [{ isPrimary: 'desc' }, { uploadedAt: 'asc' }],
      select: { url: true }
    });

    await prisma.roaster.update({
      where: { id: roasterId },
      data: {
        images: allImages.map(img => img.url)
      }
    });

    // Store entity for audit logging
    res.locals.auditEntity = updatedImage;

    res.json({
      message: 'Image updated successfully',
      image: {
        id: updatedImage.id,
        url: updatedImage.url,
        description: updatedImage.description,
        isPrimary: updatedImage.isPrimary,
        uploadedAt: updatedImage.uploadedAt,
        filename: updatedImage.filename
      },
    });
  } catch (error) {
    console.error('Update roaster image error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}, auditAfter());

/**
 * @swagger
 * /api/roasters/{id}/images/{imageId}:
 *   delete:
 *     summary: Delete a roaster image (owner or admin only)
 *     tags: [Roasters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *       - in: path
 *         name: imageId
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Image deleted successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Only owner or admin can delete images
 *       404:
 *         description: Roaster or image not found
 */
router.delete('/:id/images/:imageId', [
  param('id').isString(),
  param('imageId').isString(),
], requireAuth, auditBefore('roaster_image', 'DELETE'), captureOldValues(prisma.roasterImage, 'imageId'), canEditRoaster, async (req: any, res: any) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { id: roasterId, imageId } = req.params;

    // Get image details before deletion
    const image = await prisma.roasterImage.findFirst({
      where: {
        id: imageId,
        roasterId
      }
    });

    if (!image) {
      return res.status(404).json({ error: 'Image not found' });
    }

    // Delete from Cloudinary
    const cloudinaryDeleted = await deleteImage(image.publicId);
    if (!cloudinaryDeleted) {
      console.warn(`Failed to delete image from Cloudinary: ${image.publicId}`);
    }

    // Delete from database
    await prisma.roasterImage.delete({
      where: { id: imageId }
    });

    // Update the roaster's images array for backward compatibility
    const allImages = await prisma.roasterImage.findMany({
      where: { roasterId },
      orderBy: [{ isPrimary: 'desc' }, { uploadedAt: 'asc' }],
      select: { url: true }
    });

    await prisma.roaster.update({
      where: { id: roasterId },
      data: {
        images: allImages.map(img => img.url)
      }
    });

    // Store entity for audit logging (use captured old values)
    res.locals.auditEntity = req.auditData?.oldValues || { id: imageId };

    res.json({
      message: 'Image deleted successfully',
    });
  } catch (error) {
    console.error('Delete roaster image error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}, auditAfter());

/**
 * @swagger
 * /api/roasters/{id}/source-countries:
 *   get:
 *     summary: Get roaster's source countries
 *     tags: [Roasters]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: List of source countries for the roaster
 *       404:
 *         description: Roaster not found
 */
router.get('/:id/source-countries', async (req: any, res: any) => {
  try {
    const { id } = req.params;

    const roaster = await prisma.roaster.findUnique({
      where: { id },
      include: {
        sourceCountries: {
          include: {
            country: {
              include: {
                region: true
              }
            }
          }
        }
      }
    });

    if (!roaster) {
      return res.status(404).json({ error: 'Roaster not found' });
    }

    const countries = roaster.sourceCountries.map(sc => sc.country);
    res.json(countries);
  } catch (error) {
    console.error('Error fetching roaster source countries:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/roasters/{id}/source-countries:
 *   put:
 *     summary: Update roaster's source countries
 *     tags: [Roasters]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               countryIds:
 *                 type: array
 *                 items:
 *                   type: string
 *     responses:
 *       200:
 *         description: Source countries updated successfully
 *       404:
 *         description: Roaster not found
 *       403:
 *         description: Not authorized to edit this roaster
 */
router.put('/:id/source-countries', [
  requireAuth,
  param('id').isString().notEmpty(),
  body('countryIds').isArray(),
  body('countryIds.*').isString().notEmpty()
], async (req: any, res: any) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { id } = req.params;
    const { countryIds } = req.body;

    // Check if roaster exists and user has permission
    const roaster = await prisma.roaster.findUnique({
      where: { id }
    });

    if (!roaster) {
      return res.status(404).json({ error: 'Roaster not found' });
    }

    // Check authorization
    const user = await prisma.user.findUnique({
      where: { id: req.userId },
      select: { role: true }
    });

    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }

    // Check if user can edit this roaster (admin or owner)
    const isAdmin = user.role === 'admin';
    const isOwner = roaster.ownerId === req.userId;
    
    if (!isAdmin && !isOwner) {
      return res.status(403).json({ error: 'Not authorized to edit this roaster' });
    }

    // Validate that all country IDs exist
    if (countryIds.length > 0) {
      const countries = await prisma.country.findMany({
        where: { id: { in: countryIds } }
      });

      if (countries.length !== countryIds.length) {
        return res.status(400).json({ error: 'One or more country IDs are invalid' });
      }
    }

    // Remove existing source countries and add new ones
    await prisma.roasterSourceCountry.deleteMany({
      where: { roasterId: id }
    });

    if (countryIds.length > 0) {
      await prisma.roasterSourceCountry.createMany({
        data: countryIds.map((countryId: string) => ({
          roasterId: id,
          countryId
        }))
      });
    }

    // Fetch updated roaster with source countries
    const updatedRoaster = await prisma.roaster.findUnique({
      where: { id },
      include: {
        sourceCountries: {
          include: {
            country: {
              include: {
                region: true
              }
            }
          }
        }
      }
    });

    const countries = updatedRoaster?.sourceCountries.map(sc => sc.country) || [];
    res.json({
      message: 'Source countries updated successfully',
      countries
    });
  } catch (error) {
    console.error('Error updating roaster source countries:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
// trigger restart
