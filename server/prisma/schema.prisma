generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Search {
  id        String   @id @default(cuid())
  query     String   @unique
  count     Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model User {
  id              String          @id @default(cuid())
  email           String          @unique
  username        String          @unique
  password        String?
  firstName       String
  lastName        String
  avatar          String?
  bio             String?
  location        String?
  latitude        Float?
  longitude       Float?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  language        String          @default("en") @db.VarChar(5)
  settings        Json?
  role            String          @default("user") @db.VarChar(16)
  isDeprecated    Boolean         @default(false)
  createdById     String?
  updatedById     String?
  lastLogin       DateTime?
  auditLogs       AuditLog[]
  createdBeans    Bean[]          @relation("BeanCreatedBy")
  updatedBeans    Bean[]          @relation("BeanUpdatedBy")
  comments        Comment[]
  favourites       Favourite[]
  notifications   Notification[]
  createdReviews  Review[]        @relation("ReviewCreatedBy")
  updatedReviews  Review[]        @relation("ReviewUpdatedBy")
  reviews         Review[]
  uploadedImages  RoasterImage[]
  createdPeople   RoasterPerson[] @relation("PersonCreatedBy")
  updatedPeople   RoasterPerson[] @relation("PersonUpdatedBy")
  personRoles     RoasterPerson[] @relation("UserPersonRole")
  createdRoasters Roaster[]       @relation("RoasterCreatedBy")
  roasters        Roaster[]
  updatedRoasters Roaster[]       @relation("RoasterUpdatedBy")
  createdBy       User?           @relation("UserCreatedBy", fields: [createdById], references: [id])
  createdUsers    User[]          @relation("UserCreatedBy")
  updatedBy       User?           @relation("UserUpdatedBy", fields: [updatedById], references: [id])
  updatedUsers    User[]          @relation("UserUpdatedBy")
  passwordResetTokens PasswordResetToken[]
  oauthAccounts   OAuthAccount[]
  oauthStates     OAuthState[]

  @@map("users")
}


model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@map("password_reset_tokens")
}

model Roaster {
  id                 String                 @id @default(cuid())
  name               String                 @unique
  description        String?
  email              String?
  phone              String?
  website            String?
  address            String?
  city               String?
  state              String?
  zipCode            String?
  country            String                 @default("US")
  latitude           Float?
  longitude          Float?
  images             String[]
  hours              Json?
  verified           Boolean                @default(false)
  featured           Boolean                @default(false)
  rating             Float                  @default(0)
  reviewCount        Int                    @default(0)
  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @updatedAt
  ownerId            String?
  onlineOnly         Boolean                @default(false)
  createdById        String?
  updatedById        String?
  showHours          Boolean                @default(true)
  // Consolidated social networks as JSON (key -> url/handle).
  // We keep legacy individual columns for backward compatibility during migration.
  socialNetworks     Json?
  founded            Int?
  beans              Bean[]
  favourites          Favourite[]
  reviews            Review[]
  roasterImages      RoasterImage[]
  people             RoasterPerson[]
  posts              Post[]
  sourceCountries    RoasterSourceCountry[]
  roasterSpecialties RoasterSpecialty[]
  suggestions        RoasterSuggestion[]
  createdBy          User?                  @relation("RoasterCreatedBy", fields: [createdById], references: [id])
  owner              User?                  @relation(fields: [ownerId], references: [id])
  updatedBy          User?                  @relation("RoasterUpdatedBy", fields: [updatedById], references: [id])
    sourceType         RoasterSourceType?
    sourceDetails      String?

  @@map("roasters")
}
  enum RoasterSourceType {
    Suggestion
    Google
    GoogleMaps
    ChatGPT
    Claude
    YouTube
    Instagram
    TikTok
    API
    Other
  }

model RoasterPerson {
  id           String   @id @default(cuid())
  roasterId    String
  firstName    String
  lastName     String?
  email        String?
  mobile       String?
  linkedinUrl  String?
  instagramUrl String?
  bio          String?
  userId       String?
  roles        String[]
  isActive     Boolean  @default(true)
  isPrimary    Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  createdById  String?
  updatedById  String?
  title        String?
  createdBy    User?    @relation("PersonCreatedBy", fields: [createdById], references: [id])
  roaster      Roaster  @relation(fields: [roasterId], references: [id], onDelete: Cascade)
  updatedBy    User?    @relation("PersonUpdatedBy", fields: [updatedById], references: [id])
  user         User?    @relation("UserPersonRole", fields: [userId], references: [id])

  @@unique([roasterId, email])
  @@map("roaster_people")
}

model RoasterImage {
  id           String   @id @default(cuid())
  url          String
  publicId     String
  filename     String?
  description  String?
  isPrimary    Boolean  @default(false)
  uploadedAt   DateTime @default(now())
  updatedAt    DateTime @updatedAt
  roasterId    String
  uploadedById String
  roaster      Roaster  @relation(fields: [roasterId], references: [id], onDelete: Cascade)
  uploadedBy   User     @relation(fields: [uploadedById], references: [id])

  @@map("roaster_images")
}

model Bean {
  id           String   @id @default(cuid())
  name         String
  description  String?
  origin       String?
  process      String?
  roastLevel   String?
  price        Float?
  weight       String?
  tastingNotes String[]
  availability Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  roasterId    String
  createdById  String?
  updatedById  String?
  createdBy    User?    @relation("BeanCreatedBy", fields: [createdById], references: [id])
  roaster      Roaster  @relation(fields: [roasterId], references: [id])
  updatedBy    User?    @relation("BeanUpdatedBy", fields: [updatedById], references: [id])

  @@map("beans")
}

model Review {
  id          String    @id @default(cuid())
  rating      Int
  title       String?
  content     String?
  images      String[]
  helpful     Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  userId      String
  roasterId   String?
  createdById String?
  updatedById String?
  comments    Comment[]
  createdBy   User?     @relation("ReviewCreatedBy", fields: [createdById], references: [id])
  roaster     Roaster?  @relation(fields: [roasterId], references: [id])
  updatedBy   User?     @relation("ReviewUpdatedBy", fields: [updatedById], references: [id])
  user        User      @relation(fields: [userId], references: [id])

  @@map("reviews")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  reviewId  String
  review    Review   @relation(fields: [reviewId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@map("comments")
}

model Favourite {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  userId    String
  roasterId String
  roaster   Roaster  @relation(fields: [roasterId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, roasterId])
  @@map("favourites")
}

model Notification {
  id        String   @id @default(cuid())
  type      String
  title     String
  message   String
  read      Boolean  @default(false)
  data      Json?
  createdAt DateTime @default(now())
  userId    String
  user      User     @relation(fields: [userId], references: [id])

  @@map("notifications")
}

model Region {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  countries   Country[]

  @@map("regions")
}

model Country {
  id        String                 @id @default(cuid())
  name      String                 @unique
  code      String                 @unique @db.VarChar(2)
  flagSvg   String?
  createdAt DateTime               @default(now())
  updatedAt DateTime               @updatedAt
  regionId  String
  region    Region                 @relation(fields: [regionId], references: [id])
  roasters  RoasterSourceCountry[]

  @@map("countries")
}

model RoasterSourceCountry {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  roasterId String
  countryId String
  country   Country  @relation(fields: [countryId], references: [id])
  roaster   Roaster  @relation(fields: [roasterId], references: [id], onDelete: Cascade)

  @@unique([roasterId, countryId])
  @@map("roaster_source_countries")
}

model Specialty {
  id           String                 @id @default(cuid())
  deprecated   Boolean                @default(false)
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
  roasters     RoasterSpecialty[]
  translations SpecialtyTranslation[]

  @@map("specialties")
}

model SpecialtyTranslation {
  id          String    @id @default(cuid())
  specialtyId String
  language    String    @db.VarChar(5)
  name        String
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  specialty   Specialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)

  @@unique([specialtyId, language])
  @@map("specialty_translations")
}

model RoasterSpecialty {
  id          String    @id @default(cuid())
  roasterId   String
  specialtyId String
  createdAt   DateTime  @default(now())
  roaster     Roaster   @relation(fields: [roasterId], references: [id], onDelete: Cascade)
  specialty   Specialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)

  @@unique([roasterId, specialtyId])
  @@map("roaster_specialties")
}

model AuditLog {
  id         String   @id @default(cuid())
  action     String
  entityType String
  entityId   String
  entityName String?
  changes    Json?
  ipAddress  String?
  userAgent  String?
  city       String?
  country    String?
  createdAt  DateTime @default(now())
  userId     String?
  user       User?    @relation(fields: [userId], references: [id])

  @@index([entityType, entityId])
  @@index([userId])
  @@index([createdAt])
  @@map("audit_logs")
}

model RoasterSuggestion {
  id                String   @id @default(cuid())
  roasterName       String
  city              String
  state             String?
  country           String
  website           String
  submitterRole     String
  submitterFirstName String
  submitterLastName String?
  submitterEmail    String
  submitterPhone    String?
  status            String   @default("new") // new, approved, in_progress, rejected, done
  adminNotes        String?
  roasterId         String?  // ID of the created roaster
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  reviewedAt        DateTime?
  reviewedById      String?
  roaster           Roaster? @relation(fields: [roasterId], references: [id])

  @@map("roaster_suggestions")
}

model AnalyticsEvent {
  id         Int      @id @default(autoincrement())
  eventType  String   @db.VarChar(50)
  eventData  Json?
  timestamp  DateTime @default(now())
  sessionId  String?  @db.VarChar(100)
  userAgent  String?
  ipHash     String?  @db.VarChar(64)

  @@index([eventType], name: "idx_event_type")
  @@index([timestamp], name: "idx_timestamp")
  @@index([sessionId], name: "idx_session_id")
  @@map("analytics_events")
}

model Post {
  id             String   @id @default(cuid())
  roasterId      String
  url            String
  socialNetwork  String   @db.VarChar(20) // Instagram, Other
  postedAt       DateTime @default(now())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  createdById    String?
  roaster        Roaster  @relation(fields: [roasterId], references: [id], onDelete: Cascade)

  @@index([roasterId])
  @@index([postedAt])
  @@map("posts")
}

// OAuth Models

model OAuthAccount {
  id                String        @id @default(cuid())
  userId            String
  provider          String        @db.VarChar(32) // 'facebook', 'instagram', 'google', 'microsoft'
  providerAccountId String        // Unique ID from the OAuth provider
  email             String?       // Email from provider (may differ from user.email)
  displayName       String?       // Display name from provider
  profilePicture    String?       // Profile picture URL from provider
  metadata          Json?         // Additional provider-specific data
  scope             String[]      // OAuth scopes granted
  lastUsedAt        DateTime?     // Last time this account was used for login
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokens            OAuthToken?   // One-to-one relation

  @@unique([provider, providerAccountId])
  @@unique([userId, provider])
  @@index([userId])
  @@map("oauth_accounts")
}

model OAuthToken {
  id               String       @id @default(cuid())
  accountId        String       @unique // One-to-one with OAuthAccount
  tokenType        String       @db.VarChar(16) // 'Bearer'
  accessToken      String       @db.Text // Encrypted access token
  refreshToken     String?      @db.Text // Encrypted refresh token (optional)
  expiresAt        DateTime?    // Token expiration (null for long-lived tokens)
  scope            String[]     // OAuth scopes for this token
  lastRefreshedAt  DateTime?    // Last time the token was refreshed
  refreshFailCount Int          @default(0) // Track failed refresh attempts
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  account          OAuthAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@map("oauth_tokens")
}

model OAuthState {
  id            String   @id @default(cuid())
  state         String   @unique @db.VarChar(64) // Random state parameter
  provider      String   @db.VarChar(32)
  userId        String?  // Optional - for linking existing accounts
  codeVerifier  String?  @db.VarChar(256) // PKCE code_verifier (128 bytes base64url = ~171 chars)
  codeChallenge String?  @db.VarChar(256) // PKCE code_challenge
  redirectUrl   String?  @db.Text // Where to redirect after OAuth
  ipAddress     String?  @db.VarChar(45) // IP address for security
  userAgent     String?  @db.Text // User agent string
  expiresAt     DateTime // State expires after 10 minutes
  createdAt     DateTime @default(now())
  user          User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([state])
  @@index([expiresAt])
  @@map("oauth_states")
}
